<!DOCTYPE html>
<html>
<head>
    <title>WebGL Hello Triangle</title>
    <style>
        body { margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #333; }
        canvas { border: 1px solid #000; }
    </style>
</head>
<body>
    <canvas id="glcanvas" width="640" height="480">
        Tu navegador no soporta el elemento HTML5 canvas.
    </canvas>

    <script id="vertex-shader-2d" type="notjs">
        attribute vec4 a_position;
        attribute vec4 a_color;

        varying lowp vec4 vColor;

        void main() {
            gl_Position = a_position;
            vColor = a_color;
        }
    </script>

    <script id="fragment-shader-2d" type="notjs">
        precision mediump float;
        varying lowp vec4 vColor;

        void main(void) {
          gl_FragColor = vColor;
        }
    </script>


    <script type="text/javascript">
        //https://webglfundamentals.org/webgl/lessons/
        //https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial

        // 1. Shaders GLSL (Lenguaje de Shading de Gráficos)
        // El sombreador de vértices (Vertex Shader) procesa las posiciones de los vértices.
        //const vsSource = `
        //    attribute vec4 a_position;
        //    void main() {
        //        // gl_Position es una variable especial que almacena la posición final del vértice
        //        gl_Position = a_position;
        //    }
        //`;
//
        //// El sombreador de fragmentos (Fragment Shader) determina el color de cada píxel.
        //const fsSource = `
        //    void main() {
        //        // gl_FragColor es una variable especial que almacena el color final del fragmento (píxel)
        //        // Color RGB(1.0, 0.0, 0.0) es Rojo. El 1.0 final es el valor alfa (opacidad).
        //        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        //    }
        //`;

        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        var shaderProgram;

        // Dibuja la escena
        function drawScene(gl, vertexCount) {
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            // Limpiar el canvas (fondo azul oscuro)
            gl.clearColor(0.0, 0.0, 0.4, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Comando de dibujo final: Dibuja 3 vértices como un triángulo.
            gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
        }

        // Compila un shader (vértices o fragmentos)
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error al compilar el shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function getShaderSource(id) {
            const shaderScript = document.getElementById(id);

            if (!shaderScript) {
                throw new Error(`No se encontró el elemento script con ID: ${id}`);
            }

            // El contenido del script se encuentra en la propiedad textContent
            return shaderScript.textContent.trim();
        }

        // Crea el programa de sombreado combinando los shaders
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
   
            if (!vertexShader || !fragmentShader) 
                return null;

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('No se pudo inicializar el shader:', gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        function setupShaders() {
            // 2. Inicializar Shaders
            const vertexShader = getShaderSource('vertex-shader-2d')
            const fragmentShader = getShaderSource('fragment-shader-2d')

            shaderProgram = initShaderProgram(gl, vertexShader, fragmentShader);

            if (!shaderProgram) return;

            // Usar el programa recién creado
            gl.useProgram(shaderProgram);

        }

        function setupGeometry() {
            // 3. Crear Geometría (Datos del Triángulo)
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Coordenadas en espacio de recorte (clip space): de -1.0 a +1.0
            const positions = new Float32Array([

                -1.0, 1.0, 0.0, 1.0,  // Arriba izquierda
                -1.0, -1.0, 0.0, 1.0, // Abajo izquierda
                1.0, -1.0, 0.0, 1.0   // abajo derecha
            ]);

            // Pasar los datos de posición a la GPU
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            // 4. Conectar Geometría al Atributo del Shader
            const positionLocation = gl.getAttribLocation(shaderProgram, 'a_position');

            // Habilitar el atributo
            gl.enableVertexAttribArray(positionLocation);

            // Especificar cómo la GPU debe leer los datos del buffer
            gl.vertexAttribPointer(
                positionLocation, // Localización del atributo
                4,                // Número de componentes por vértice (x, y, z, w)
                gl.FLOAT,         // Tipo de datos en el buffer
                false,            // Normalizar datos (no aplicable aquí)
                0,                // Stride (paso) - 0 significa que los datos están densamente empacados
                0                 // Offset (desplazamiento) - Dónde comenzar
            );
        }
        function setupColorBuffer() {
            const colors = [              
                1.0,
                0.0,
                0.0,
                1.0, // red
                0.0,
                1.0,
                0.0,
                1.0, // green
                0.0,
                0.0,
                1.0,
                1.0, // blue
            ];

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            // 4. Conectar Geometría al Atributo del Shader

            const colorLocation = gl.getAttribLocation(shaderProgram, 'a_color');

            // Habilitar el atributo
            gl.enableVertexAttribArray(colorLocation);

            // Especificar cómo la GPU debe leer los datos del buffer
            gl.vertexAttribPointer(
                colorLocation, // Localización del atributo
                4,                // Número de componentes por vértice (x, y, z, w)
                gl.FLOAT,         // Tipo de datos en el buffer
                false,            // Normalizar datos (no aplicable aquí)
                0,                // Stride (paso) - 0 significa que los datos están densamente empacados
                0                 // Offset (desplazamiento) - Dónde comenzar
            );

        }

        function main() {
            
            if (!gl) {
                alert('No se pudo inicializar WebGL. Tu navegador podría no soportarlo.');
                return;
            }

            setupShaders();
            setupGeometry();                      
            setupColorBuffer();
            // 5. Dibujar
            drawScene(gl, 3);
        }

        // Ejecutar la función principal al cargar la página
        window.onload = main;
    </script>
</body>
</html>